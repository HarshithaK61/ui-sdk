const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./Byf87tck.js","./8NJXV5Ny.js","./CIKIahH0.js","./entry.Bv58BlFP.css"])))=>i.map(i=>d[i]);
import{d as j,j as f,G as D,i as G,l as W,D as B,H as F,x as O,o as P,y as I,e as b,I as z,a as _,c as k,b as R,F as x,J as H,C as M,K as $}from"./CIKIahH0.js";import{_ as J}from"./BAwDIf_H.js";import{G as A}from"./C3yoewId.js";import"./DrY-ABih.js";const K={class:"p-4 space-y-4"},L={key:0,class:"text-red-500 text-sm"},Q={key:1,class:"text-green-600 text-sm"},Z={class:"space-y-2"},X={class:"flex gap-2"},Y="8b6c46b9127ce91195745c124870244e",C="ccd:4221332d34e1694168c2a0c0b3fd0f27",y="request_verifiable_presentation_v1",ne=j({__name:"zkp",setup(ee){const c=f(""),m=f(!1),h=f(!1),s=f(null),n=f(null),t=D(null),u=D(null),S=f(!1);function p(e,o){o==="red"?(s.value=e,n.value=null):(n.value=e,s.value=null)}const U=G(()=>h.value&&c.value.trim()&&!m.value);W(async()=>{try{const{SignClient:e}=await B(async()=>{const{SignClient:o}=await import("./Byf87tck.js");return{SignClient:o}},__vite__mapDeps([0,1,2,3]),import.meta.url);t.value=await e.init({projectId:Y,metadata:{name:"Account Wallet",description:"Account Wallet for Concordium",url:"https://example.com",icons:[]}}),q(),h.value=!0}catch(e){s.value="Failed to initialize WalletConnect",console.error("SignClient init error:",e)}}),F(()=>{t.value=null});function q(){t.value&&(t.value.on("session_proposal",async e=>{console.log("Received session proposal:",e);try{const{id:o,params:r}=e,{requiredNamespaces:d,optionalNamespaces:v}=r,a={};for(const[g,i]of Object.entries(d||{}))a[g]={accounts:i.chains?.map(w=>`${w}:account`)||[],methods:i.methods||[],events:i.events||[]};for(const[g,i]of Object.entries(v||{}))a[g]||(a[g]={accounts:i.chains?.map(w=>`${w}:account`)||[],methods:i.methods||[],events:i.events||[]});const l=await t.value.approve({id:o,namespaces:a});console.log("Session approved:",l),n.value="Session approved"}catch(o){console.error("Failed to approve session:",o),s.value=o instanceof Error?o.message:"Failed to approve session"}}),t.value.on("session_request",async e=>{const{topic:o,params:r,id:d}=e,{request:v}=r;if(v.method===y){console.log("Received Identity Request from Website. Bridging to IDApp...");try{const a=u.value??await N();if(!a)throw new Error("Failed to connect to IDApp");const l=await t.value.request({topic:a.topic,chainId:C,request:{method:y,params:v.params}});await t.value.respond({topic:o,response:{id:d,result:l,jsonrpc:"2.0"}}),console.log("Proof successfully bridged to Website."),A.closePopup(),n.value="Proof successfully sent"}catch(a){const l=a instanceof Error?a.message:"User rejected or IDApp error";await t.value.respond({topic:o,response:{id:d,error:{code:5e3,message:l},jsonrpc:"2.0"}}),s.value=l}}}))}async function E(){if(!(!t.value||!c.value.trim())){m.value=!0,s.value=null,n.value=null;try{await t.value.pair({uri:c.value.trim()}),n.value="Pairing successful",c.value=""}catch(e){s.value=e instanceof Error?e.message:"Pairing failed",console.error("Pairing error:",e)}finally{m.value=!1}}}async function N(){if(!t.value)return null;try{const{uri:e,approval:o}=await t.value.connect({requiredNamespaces:{ccd:{methods:[y],chains:[C],events:[]}}});e&&(console.log("Opening IDApp with URI:",e),A.invokeIdAppDeepLinkPopup({walletConnectUri:e,actionType:"generate-proof"}));const r=await o();return u.value=r,await V(),r}catch(e){return console.error("IDApp connection error:",e),null}}async function V(){if(S.value=!0,p("Session approved! Ready to generate proof.","green"),t.value&&u.value){const e=u.value.topic;if(!e){p("No ID App session found","red");return}A.invokeIdAppActionsPopup({generateProof:async()=>{await T()},walletConnectSessionTopic:e})}}async function T(){if(!t.value||!u.value){p("No IDApp session available","red");return}try{p("Generating proof...","green");const e=await t.value.request({topic:u.value.topic,chainId:C,request:{method:y,params:{}}});console.log("Proof generated:",e),p("Proof generated successfully!","green")}catch(e){console.error("Generate proof error:",e),p(e instanceof Error?e.message:"Failed to generate proof","red")}}return(e,o)=>{const r=J,d=H,v=z,a=$;return P(),O(a,null,{default:I(()=>[b(v,null,{default:I(()=>[_("div",K,[o[2]||(o[2]=_("h2",{class:"text-xl font-bold mb-4"},"ZKP Verification - Scan Merchant QR",-1)),s.value?(P(),k("div",L,x(s.value),1)):R("",!0),n.value?(P(),k("div",Q,x(n.value),1)):R("",!0),_("div",Z,[o[1]||(o[1]=_("label",{class:"block text-sm font-medium"},"Wallet URI",-1)),_("div",X,[b(r,{modelValue:c.value,"onUpdate:modelValue":o[0]||(o[0]=l=>c.value=l),placeholder:"wc:...",class:"flex-1",size:"sm",disabled:!h.value},null,8,["modelValue","disabled"]),b(d,{color:"primary",size:"sm",disabled:!U.value,loading:m.value,onClick:E},{default:I(()=>[M(x(m.value?"Pairing...":"Pair"),1)]),_:1},8,["disabled","loading"])])])])]),_:1})]),_:1})}}});export{ne as default};
