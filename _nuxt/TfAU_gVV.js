import{k as yt,m as tt,i as ht,n as bt,o as pt}from"./zLhPEJt6.js";const xt={p:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,n:0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,a:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,d:0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,Gx:0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,Gy:0x6666666666666666666666666666666666666666666666666666666666666658n},{p:h,n:S,Gx:k,Gy:J,a:N,d:O}=xt,mt=8n,T=32,L=64,p=(t="")=>{throw new Error(t)},wt=t=>typeof t=="bigint",nt=t=>typeof t=="string",gt=t=>t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array",A=(t,n)=>!gt(t)||typeof n=="number"&&n>0&&t.length!==n?p("Uint8Array expected"):t,Y=t=>new Uint8Array(t),U=t=>Uint8Array.from(t),st=(t,n)=>t.toString(16).padStart(n,"0"),V=t=>Array.from(A(t)).map(n=>st(n,2)).join(""),g={_0:48,_9:57,A:65,F:70,a:97,f:102},K=t=>{if(t>=g._0&&t<=g._9)return t-g._0;if(t>=g.A&&t<=g.F)return t-(g.A-10);if(t>=g.a&&t<=g.f)return t-(g.a-10)},H=t=>{const n="hex invalid";if(!nt(t))return p(n);const s=t.length,o=s/2;if(s%2)return p(n);const f=Y(o);for(let c=0,r=0;c<o;c++,r+=2){const a=K(t.charCodeAt(r)),i=K(t.charCodeAt(r+1));if(a===void 0||i===void 0)return p(n);f[c]=a*16+i}return f},D=(t,n)=>A(nt(t)?H(t):U(A(t)),n),et=()=>globalThis?.crypto,Bt=()=>et()?.subtle??p("crypto.subtle must be defined"),X=(...t)=>{const n=Y(t.reduce((o,f)=>o+A(f).length,0));let s=0;return t.forEach(o=>{n.set(o,s),s+=o.length}),n},At=(t=T)=>et().getRandomValues(Y(t)),z=BigInt,B=(t,n,s,o="bad number: out of range")=>wt(t)&&n<=t&&t<s?t:p(o),e=(t,n=h)=>{const s=t%n;return s>=0n?s:n+s},ot=t=>e(t,S),ct=(t,n)=>{(t===0n||n<=0n)&&p("no inverse n="+t+" mod="+n);let s=e(t,n),o=n,f=0n,c=1n;for(;s!==0n;){const r=o/s,a=o%s,i=f-c*r;o=s,s=a,f=c,c=i}return o===1n?e(f,n):p("no inverse")},W=t=>t instanceof b?t:p("Point expected"),q=2n**256n;class b{static BASE;static ZERO;ex;ey;ez;et;constructor(n,s,o,f){const c=q;this.ex=B(n,0n,c),this.ey=B(s,0n,c),this.ez=B(o,1n,c),this.et=B(f,0n,c),Object.freeze(this)}static fromAffine(n){return new b(n.x,n.y,1n,e(n.x*n.y))}static fromBytes(n,s=!1){const o=O,f=U(A(n,T)),c=n[31];f[31]=c&-129;const r=rt(f);B(r,0n,s?q:h);const i=e(r*r),d=e(i-1n),u=e(o*i+1n);let{isValid:l,value:y}=_t(d,u);l||p("bad point: y not sqrt");const x=(y&1n)===1n,m=(c&128)!==0;return!s&&y===0n&&m&&p("bad point: x==0, isLastByteOdd"),m!==x&&(y=e(-y)),new b(y,r,1n,e(y*r))}assertValidity(){const n=N,s=O,o=this;if(o.is0())throw new Error("bad point: ZERO");const{ex:f,ey:c,ez:r,et:a}=o,i=e(f*f),d=e(c*c),u=e(r*r),l=e(u*u),y=e(i*n),x=e(u*e(y+d)),m=e(l+e(s*e(i*d)));if(x!==m)throw new Error("bad point: equation left != right (1)");const _=e(f*c),R=e(r*a);if(_!==R)throw new Error("bad point: equation left != right (2)");return this}equals(n){const{ex:s,ey:o,ez:f}=this,{ex:c,ey:r,ez:a}=W(n),i=e(s*a),d=e(c*f),u=e(o*a),l=e(r*f);return i===d&&u===l}is0(){return this.equals(Z)}negate(){return new b(e(-this.ex),this.ey,this.ez,e(-this.et))}double(){const{ex:n,ey:s,ez:o}=this,f=N,c=e(n*n),r=e(s*s),a=e(2n*e(o*o)),i=e(f*c),d=n+s,u=e(e(d*d)-c-r),l=i+r,y=l-a,x=i-r,m=e(u*y),_=e(l*x),R=e(u*x),v=e(y*l);return new b(m,_,v,R)}add(n){const{ex:s,ey:o,ez:f,et:c}=this,{ex:r,ey:a,ez:i,et:d}=W(n),u=N,l=O,y=e(s*r),x=e(o*a),m=e(c*l*d),_=e(f*i),R=e((s+o)*(r+a)-y-x),v=e(_-m),M=e(_+m),j=e(x-u*y),at=e(R*v),dt=e(M*j),ut=e(R*j),lt=e(v*M);return new b(at,dt,lt,ut)}multiply(n,s=!0){if(!s&&(n===0n||this.is0()))return Z;if(B(n,1n,S),n===1n)return this;if(this.equals(E))return Yt(n).p;let o=Z,f=E;for(let c=this;n>0n;c=c.double(),n>>=1n)n&1n?o=o.add(c):s&&(f=f.add(c));return o}toAffine(){const{ex:n,ey:s,ez:o}=this;if(this.equals(Z))return{x:0n,y:1n};const f=ct(o,h);return e(o*f)!==1n&&p("invalid inverse"),{x:e(n*f),y:e(s*f)}}toBytes(){const{x:n,y:s}=this.assertValidity().toAffine(),o=ft(s);return o[31]|=n&1n?128:0,o}toHex(){return V(this.toBytes())}clearCofactor(){return this.multiply(z(mt),!1)}isSmallOrder(){return this.clearCofactor().is0()}isTorsionFree(){let n=this.multiply(S/2n,!1).double();return S%2n&&(n=n.add(this)),n.is0()}static fromHex(n,s){return b.fromBytes(D(n),s)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}toRawBytes(){return this.toBytes()}}const E=new b(k,J,1n,e(k*J)),Z=new b(0n,1n,1n,0n);b.BASE=E;b.ZERO=Z;const ft=t=>H(st(B(t,0n,q),L)).reverse(),rt=t=>z("0x"+V(U(A(t)).reverse())),w=(t,n)=>{let s=t;for(;n-- >0n;)s*=s,s%=h;return s},Et=t=>{const s=t*t%h*t%h,o=w(s,2n)*s%h,f=w(o,1n)*t%h,c=w(f,5n)*f%h,r=w(c,10n)*c%h,a=w(r,20n)*r%h,i=w(a,40n)*a%h,d=w(i,80n)*i%h,u=w(d,80n)*i%h,l=w(u,10n)*c%h;return{pow_p_5_8:w(l,2n)*t%h,b2:s}},P=0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n,_t=(t,n)=>{const s=e(n*n*n),o=e(s*s*n),f=Et(t*o).pow_p_5_8;let c=e(t*s*f);const r=e(n*c*c),a=c,i=e(c*P),d=r===t,u=r===e(-t),l=r===e(-t*P);return d&&(c=a),(u||l)&&(c=i),(e(c)&1n)===1n&&(c=e(-c)),{isValid:d||u,value:c}},F=t=>ot(rt(t)),I=(...t)=>Xt.sha512Async(...t),Rt=t=>{const n=t.slice(0,T);n[0]&=248,n[31]&=127,n[31]|=64;const s=t.slice(T,L),o=F(n),f=E.multiply(o),c=f.toBytes();return{head:n,prefix:s,scalar:o,point:f,pointBytes:c}},Zt=t=>I(D(t,T)).then(Rt),Tt=t=>I(t.hashable).then(t.finish),vt=(t,n,s)=>{const{pointBytes:o,scalar:f}=t,c=F(n),r=E.multiply(c).toBytes();return{hashable:X(r,o,s),finish:d=>{const u=ot(c+F(d)*f);return A(X(r,ft(u)),L)}}},St=async(t,n)=>{const s=D(t),o=await Zt(n),f=await I(o.prefix,s);return Tt(vt(o,f,s))},Xt={sha512Async:async(...t)=>{const n=Bt(),s=X(...t);return Y(await n.digest("SHA-512",s.buffer))},sha512Sync:void 0,bytesToHex:V,hexToBytes:H,concatBytes:X,mod:e,invert:ct,randomBytes:At},C=8,zt=256,it=Math.ceil(zt/C)+1,G=2**(C-1),Ct=()=>{const t=[];let n=E,s=n;for(let o=0;o<it;o++){s=n,t.push(s);for(let f=1;f<G;f++)s=s.add(n),t.push(s);n=s.double()}return t};let Q;const $=(t,n)=>{const s=n.negate();return t?s:n},Yt=t=>{const n=Q||(Q=Ct());let s=Z,o=E;const f=2**C,c=f,r=z(f-1),a=z(C);for(let i=0;i<it;i++){let d=Number(t&r);t>>=a,d>G&&(d-=c,t+=1n);const u=i*G,l=u,y=u+Math.abs(d)-1,x=i%2!==0,m=d<0;d===0?o=o.add($(x,n[l])):s=s.add($(m,n[y]))}return{p:s,f:o}};function Ot(t){const n=bt([tt.Buffer.from(t,"hex")]);return pt(n)}function qt(t,n){const{sigRetrievelRandomness:s,...o}=t,f={...o,blindingRandomness:t.sigRetrievelRandomness},c=ht.createUnsignedCredentialV1(JSON.stringify(f));let r;try{r=JSON.parse(c)}catch{throw new Error(c)}return{expiry:n,...r}}async function Ft(t,n){const s=yt(t);return tt.Buffer.from(await St(s,n)).toString("hex")}export{qt as c,Ot as g,Ft as s};
